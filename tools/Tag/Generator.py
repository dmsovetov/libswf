import sys

sys.path.append( "../../../tools/scripts/" )

from Template import Template

# class Generator
class Generator:
    # ctor
    def __init__( self ):
        pass

    # generateTags
    @classmethod
    def generateTags( cls, fileName, items ):
        tags = ''

        for item in items:
            tags += '#include "{0}.h"\n'.format( item )

        Template( Generator.Tags ).compileToFile( fileName, { 'tags': tags } )

    # generate
    def generate( self, fileName, tag ):
        id = Template( Generator.Id ).compile( { 'header': tag.header } ) if tag.header else ''
        Template( Generator.Header ).compileToFile( fileName, { 'id': id, 'name': tag.name, 'fields': self.generateFields( tag ), 'code': self.generateCode( tag ) } )

    # generateFields
    def generateFields( self, tag ):
        result = ''

        for field in tag.fields:
            result += Template( Generator.Field ).compile( { 'type': field.type.name, 'name': field.name } )

        return result

    # generateCode
    def generateCode( self, tag ):
        result = ''

        for field in tag.fields:
            condition = ''

            if field.condition:
                condition = Template( Generator.Condition ).compile( { 'expr': field.condition } )

            if field.type.name in Generator.BuiltInTypes:
                tpl     = Generator.ReadBits if field.type.name.endswith( 'b' ) else Generator.ReadBuiltIn
                result += Template( tpl ).compile( { 'type': field.type.name.title(), 'field': field.name, 'size': field.type.count, 'condition': condition } )
            else:
                result += Template( Generator.ReadTag ).compile( { 'type': field.type.name, 'field': field.name, 'size': field.type.count, 'condition': condition } )

        return result

    BuiltInTypes = ['s8', 's16', 's32', 'u8', 'u16', 'u32', 'f32', 'f64', 'ub', 'sb', 'fb']

    # Header
    Header = """/// Autogenerated by swftag tool

#ifndef __swftag_{name}_H__
#define __swftag_{name}_H__

#include "Tags.h"

namespace swf {

namespace tags {

    struct {name} {
{id}
{fields}

        void read( int version, stream* input )
        {
{code}
        }

        static {name} read( int version, stream* input )
        {
            {name} result;
            result.read( version, input )
            return result;
        }
    };

} // namespace tags

} // namespace swf

#endif  /*  !__swftag_{name}_H__    */
"""

    # Tags
    Tags = """/// Autogenerated by swftag tool

#ifndef __swftag_Tags_H__
#define __swftag_Tags_H__

{tags}

namespace swf {

namespace tags {

    typedef unsigned char   u8;
    typedef unsigned short  u16;
    typedef unsigned int    u32;

    typedef signed char     s8;
    typedef signed short    s16;
    typedef signed int      s32;

    typedef float           f32;
    typedef double          f64;

    typedef signed int      sb;
    typedef unsigned int    ub;
    typedef float           fb;

} // namespace tags

} // namespace swf

#endif  /*  !__swftag_Tags_H__    */
"""

    Id          = '\t\tenum { Id = {header} };'
    Field       = '\t\t{type}   {name};\n'
    ReadBuiltIn = '\t\t\t{condition}{field} = input->read{type}();\n'
    ReadBits    = '\t\t\t{condition}{field} = input->read{type}({size});\n'
    ReadTag     = '\t\t\t{condition}{field} = {type}::read( version, stream );\n'
    Condition   = 'if( {expr} ) '